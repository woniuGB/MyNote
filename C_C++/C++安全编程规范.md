# C语言/C++安全编程规范

防御性编程策略包含

```c++
变量声明应该赋予初值
谨慎使用全局变量
避免使用功能复杂、易用错的函数
禁用易用错的编译器/操作系统的机制
小心处理资源访问过程
不要改变操作系统的运行环境（创建临时文件、修改环境变量、创建进程等）
严格的错误处理
合理使用调试断言（ASSERT）
```

外部数据有那些

```c++
文件（包括程序的配置文件）
注册表
网络
环境变量
命令行
用户输入（包括命令行、界面）
用户态数据（对于内核程序）
进程间通信（包括管道、消息、共享内存、socket、RPC等）
函数参数（对于API）
全局变量（在本函数内，其他线程会修改全局变量）
```

# 1 基础要求

## 1.1 变量

规则1.1.1：指针变量、表示资源描述符的变量、BOOL变量声明必须赋予初值。

例外： 全局变量在程序被加载后会自动被赋值为0，对于要设置初值为0的全局变量，可以不进行强制赋予初值。

规则1.1.2：指向资源句柄或描述符的变量，在资源释放后立即赋予新值

规则1.1.3：类的成员变量必须在构造函数中赋予初值

规则1.1.4：严禁对指针变量进行sizeof操作

建议1.1.1：尽量使用const

建议1.1.2：全局变量的访问如果涉及多个线程，需要考虑多线程竞争条 件问题 

建议1.1.3：同一个函数内，局部变量所占用的空间不要过大 

## 1.2 断言(ASSERT) 

断言必须用宏进行定义，只在调试版本有效，最终发布版本不允许出现assert函数

断言被触发后，说明程序出现了不应该出现的严重错误，程序会立即提示错误，并终止执行。 

规则1.2.1：断言必须使用宏定义，禁止直接调用系统提供的assert() 

规则1.2.2：运行时可能会导致的错误，严禁使用断言 

​	断言不能用于校验程序在运行期间可能导致的错误。 

规则1.2.3：严禁在断言内改变运行环境 

​	ASSERT(p1 = p2); //p1被修改

​	ASSERT(i++ > 1000); //i被修改

​	ASSERT(close(fd) == 0);//fd被关闭 

建议1.2.1：不要将多条语句放在同一个断言中 

## 1.3 函数 

规则1.3.1：数组作为函数参数时，必须同时将其长度作为函数的参数

规则1.3.2：严禁对公共接口API函数的参数进行ASSERT操作

规则1.3.3：不对内容进行修改的指针型参数，定义为const 

建议1.3.1：谨慎使用不可重入函数 

```c
不可重入函数在多线程环境下其执行结果不能达到预期效果，需谨慎使用。常见的不可重入函数包括：
rand, srand
getenv, getenv_s
strtok
strerror
asctime, ctime, localtime, gmtime
setlocale
atomic_init
tmpnam
mbrtoc16, c16rtomb, mbrtoc32, c32rtomb
gethostbyaddr
gethostbyname
inet_ntoa
```

建议1.3.2：字符串或指针作为函数参数时，请检查参数是否为NULL 

建议1.3.3：在函数的开始处对参数进行ASSERT操作（API除外） 

## 1.4 循环 

规则1.4.1：循环必须有退出条件 

## 1.5 异常机制 

规则1.5.1：禁用C++异常机制 

## 1.6 类 

规则1.6.1：如果有构造函数，则必须有析构函数 

规则1.6.2：构造函数内不能做任何有可能失败的操作 

规则1.6.3：严禁在构造函数中创建线程 

规则1.6.4：严禁出现 delete this操作 

规则1.6.5：如果类的公共接口中返回类的私有数据地址，则必须加const 类型 

建议1.6.1：尽量避免定义public成员 

## 1.7 安全退出 

规则1.7.1：禁用atexit函数 

规则1.7.2：严禁调用kill、TerminateProcess函数终止其他进程 

规则1.7.3：禁用pthread_exit、ExitThread函数 

建议1.7.1：禁用exit、ExitProcess函数（main函数除外） 

建议1.7.2：禁用abort函数 

# 2 字符串/数组操作 

规则2.1：确保有足够的存储空间 

​	部分字符串处理函数由于设计时安全考虑不足，或者存在一些隐含的目的缓冲区长度要求，容易被误用，导致缓冲区写溢出。典型函数如itoa，realpath。 

规则2.2：对字符串进行存储操作，确保字符串有’\0’结束符 

规则2.3：外部数据作为数组索引时必须确保在数组大小范围内 

规则2.4：外部输入作为内存操作相关函数的复制长度时，需要校 验其合法性 

规则2.5：调用格式化函数时，禁止format参数由外部可控 

规则2.6：调用格式化函数时，format中参数的类型与个数必须 与实际参数类型一致 

# 3 正确使用安全函数 

规则 3.1：正确设置安全函数中的destMax参数 

规则 3.2：禁止封装安全函数 

规则 3.3：禁止用宏重命名安全函数 

规则 3.4：禁止自定义安全函数 

规则 3.5：必须检查安全函数返回值，并进行正确的处理 

​	原则上，如果使用了安全函数，需要进行返回值检查。如果返回值!=EOK, 那么本函数一般情况下应该立即返回，不 能继续执行。 

​	例外1： 规则6.6 禁止使用内存操作类危险函数中的例外场景中描述了允许继续使用不安全函数的场景，场景(1)-(5)对应的代 码如果使用了安全函数，可以不进行返回值检查。 

​	例外2： 在安全函数返回值检查错误处理代码中，如果又调用了安全函数，可以不进行返回值检查。 例如，在以下代码中，调用strcpy_s失败后，错误处理代码试图记录日志，在错误处理代码内又调用了sprintf_s安全 函数，此时不需要进行返回值检查。（编码人员需要仔细检查该语句不会产生安全问题） 

# 4 整数 

规则4.1：整数之间运算时必须严格检查，确保不会出现溢出、反 转、除0

规则4.2：整型表达式比较或赋值为一种更大类型之前必须用这种 更大类型对它进行求值

规则4.3：禁止对有符号整数进行位操作符运算

​	位操作符（～、>>、<<、&、^、|)应该只用于无符号整型操作数。 

​	例外： 对于视频、音频、图像等数学运算操作，可以例外。 

规则4.4：禁止整数与指针间的互相转化 

规则4.5：循环次数如果受外部数据控制，需要校验其合法性 

建议4.1：禁止对指针进行逻辑或位运算（&&、||、!、～、>>、 <<、&、 ^ 、|） 

# 5 内存 

规则5.1：内存申请前，必须对申请内存大小进行合法性校验 

规则5.2：内存分配后必须判断是否成功 

规则5.4：内存释放之后立即赋予新值 

规则5.5：禁止使用realloc()函数 

规则5.6：禁止使用alloca()函数申请栈上内存 

# 6 不安全函数 

规则6.1：禁止外部可控数据作为system、popen、WinExec、ShellExecute、execl, execlp, execle, execv, execvp、CreateProcess等进程启动函数的参数

规则6.2：禁止外部可控数据作为dlopen/LoadLibrary等模块加载函数的参数

规则6.3：禁止使用外部数据拼接SQL命令

规则6.4：禁止在信号处理例程中调用非异步安全函数

规则6.5：禁用setjmp/longjmp

规则6.6：禁止使用内存操作类危险函数 

# 7 文件输入/输出 

规则7.1：创建文件时必须显式指定合适的文件访问权限 

规则7.2：必须对文件路径进行规范化后再使用 

规则7.3：不要在共享目录中创建临时文件 

建议7.1：在进行文件操作时避免引起竞争条件 

# 8 敏感信息处理 

规则8.1：禁用rand函数产生用于安全用途的伪随机数 

规则8.2：内存中的敏感信息使用完毕后立即清0 

规则8.3：严禁使用string类存储敏感信息 

